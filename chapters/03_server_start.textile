Right after that Merb.environment and Merb.root are initialized from Merb configuration,
and accordingly to action specified on command line Merb instance is either killed or started.

Merb.start can be found in lib/merb-core.rb in Merb-core Git repository.

Merb.start (lib/merb-core.rb):
<pre>
# Start Merb by setting up the Config and then starting the server.
# Set the Merb application environment and the root path.
#
# ==== Parameters
# argv<String, Hash>::
#   The config arguments to start Merb with. Defaults to +ARGV+.
#
# @api public
def start(argv = ARGV)
  Merb::Config[:log_stream] = STDOUT
  if Hash === argv
    Merb::Config.setup(argv)
  else
    Merb::Config.parse_args(argv)
  end
  Merb::Config[:log_stream] = STDOUT
  
  Merb.environment = Merb::Config[:environment]
  Merb.root = Merb::Config[:merb_root]

  case Merb::Config[:action]
  when :kill
    Merb::Server.kill(Merb::Config[:port], 2)
  when :kill_9
    Merb::Server.kill(Merb::Config[:port], 9)
  when :fast_deploy
    Merb::Server.kill("main", "HUP")
  else
    Merb::Server.start(Merb::Config[:port], Merb::Config[:cluster])
    @started = true
  end
end
</pre>


On server start Merb has to figure out whether other instance
is already bound to given port(s), so
it calculates pid file path, reads it and checks the process if it's alive.

If not, Merb runs bootloader and starts Rack adapter. This pid file requirement
means that if you set Merb port, daemonization options or pid file
location in init file of your application, it would have no effect
on application start because init file is loaded later in the
process. So you must specify port, daemonization option and pid file
location from command line or in the startup script you may use
instead of default merb executable.


Merb::Server.start (lib/merb-core/server.rb):
<pre>
# Start a Merb server, in either foreground, daemonized or cluster mode.
#
# ==== Parameters
# port<~to_i>::
#   The port to which the first server instance should bind to.
#   Subsequent server instances bind to the immediately following ports.
# cluster<~to_i>::
#   Number of servers to run in a cluster.
#
# ==== Alternatives
# If cluster is left out, then one process will be started. This process
# will be daemonized if Merb::Config[:daemonize] is true.
#
# @api private
def start(port, cluster=nil)

  @port = port
  @cluster = cluster

  if Merb::Config[:daemonize]
    pidfile = pid_file(port)
    pid = File.read(pidfile).chomp.to_i if File.exist?(pidfile)

    unless alive?(@port)
      remove_pid_file(@port)
      Merb.logger.warn! "Daemonizing..." if Merb::Config[:verbose]
      daemonize(@port)
    else
      Merb.fatal! "Merb is already running on port #{port}.\n" \
        "\e[0m   \e[1;31;47mpid file: \e[34;47m#{pidfile}" \
        "\e[1;31;47m, process id is \e[34;47m#{pid}."
    end
  else
    bootup
  end
end
</pre>

Most of methods used here are simple. The most tricky thing
is probably how daemonization works.
Merb forks off and child process places itself into a new group,
becoming a group leader thus detaches from tty.
Then child process reopens streams: stdin and stdout to /dev/null,
stderr to stdout, and starts trapping TERM signal.
Original process exits.

A couple of notes: child process chdirs to wherever Merb.root
points to, pid file is removed on exit.

Merb::Server#daemonize (lib/merb-core/server.rb):
<pre>
# ==== Parameters
# port<~to_s>:: The port of the Merb process to daemonize.
#
# @api private
def daemonize(port)
  Merb.logger.warn! "About to fork..." if Merb::Config[:verbose]
  fork do
    Process.setsid
    exit if fork
    Merb.logger.warn! "In #{Process.pid}" if Merb.logger
    File.umask 0000
    STDIN.reopen "/dev/null"
    STDOUT.reopen "/dev/null", "a"
    STDERR.reopen STDOUT
    begin
      Dir.chdir Merb::Config[:merb_root]
    rescue Errno::EACCES => e
      Merb.fatal! "You specified Merb root as #{Merb::Config[:merb_root]}, " \
        "yet the current user does not have access to it. ", e
    end
    at_exit { remove_pid_file(port) }
    Merb::Config[:port] = port
    bootup
  end
rescue NotImplementedError => e
  Merb.fatal! "Daemonized mode is not supported on your platform. ", e
end
</pre>

In both daemon and foreground run scenarios, boot is started next
by calling Merb::Server.bootup:

<pre>
# Starts up Merb by running the bootloader and starting the adapter.
#
# @api private
def bootup
  Merb.trap("TERM") { shutdown }

  Merb.logger.warn! "Running bootloaders..." if Merb::Config[:verbose]
  BootLoader.run
  Merb.logger.warn! "Starting Rack adapter..." if Merb::Config[:verbose]
  Merb.adapter.start(Merb::Config.to_hash)
end
</pre>

Bootloader loads and initializes the framework, application code and does
things like template inlining (don't worry if you do not know what
it means, it's nothing special really).

Since boot process involves several steps and is important part of
the framework operation, it takes the whole next chapter.


Now let's look at how pid file is stored removed. It's simple.
When we store process id to the file (so other programs can
figure out what Merb process id for certain port is), we
follow simple convention:

* Pid file contains one integer: current process id.
* Pid file is stored to the same directory as logs.
* Pid file is named as "merb.N.pid" where N is port number.
* Master process (more about it in the next chapter) is named as "merb.master.pid".

Merb::Server.store_details (merb-core/lib/merb-core/server.rb)
<pre>
# Stores a PID file on the filesystem.
# This uses :pid_file options from configuration when provided
# or merb.<port>.pid in log directory by default.
#
# ==== Parameters
# port<~to_s>::
#   The port of the Merb process to whom the the PID file belongs to.
#
# ==== Alternatives
# If Merb::Config[:pid_file] has been specified, that will be used
# instead of the port/socket based PID file.
#
# @api private
def store_pid(port)
  store_details(port)
end
</pre>

Merb::Server.store_details (merb-core/lib/merb-core/server.rb)
<pre>
# Stores a PID file on the filesystem.
# This uses :pid_file options from configuration when provided
# or merb.<port/socket>.pid in log directory by default.
#
# ==== Parameters
# port<~to_s>::
#   The port of the Merb process to whom the the PID file belongs to.
#
# ==== Alternatives
# If Merb::Config[:pid_file] has been specified, that will be used
# instead of the port/socket based PID file.
#
# @api private
def store_details(port = nil)
  file = pid_file(port)
  begin
    FileUtils.mkdir_p(File.dirname(file))
  rescue Errno::EACCES => e
    Merb.fatal! "Failed to store Merb logs in #{File.dirname(file)}, " \
      "permission denied. ", e
  end
  Merb.logger.warn! "Storing #{type} file to #{file}..." if Merb::Config[:verbose]
    begin
      File.open(file, 'w'){ |f| f.write(Process.pid.to_s) }
    rescue Errno::EACCES => e
      Merb.fatal! "Failed to access #{file}, permission denied.", e
    end
  end
</pre>

and here is aforementioned naming scheme implementation:

Merb::Server.pid_file (merb-core/lib/merb-core/server.rb)
<pre>
# Gets the pid file for the specified port/socket.
#
# ==== Parameters
# port<~to_s>::
#   The port/socket of the Merb process to whom the the PID file belongs to.
#
# ==== Returns
# String::
#   Location of pid file for specified port. If clustered and pid_file option
#   is specified, it adds the port/socket value to the path.
#
# @api private
def pid_file(port)
  pidfile = Merb::Config[:pid_file] || (Merb.log_path / "merb.%s.pid")
  pidfile % port
end
</pre>

* Merb calculates path to pid file using port it bound to and
  simple conventions.
* If pid file exists, it's removed from the file system.

<pre>
# Removes a PID file used by the server from the filesystem.
# This uses :pid_file options from configuration when provided
# or merb.<port/socket>.pid in log directory by default.
#
# ==== Parameters
# port<~to_s>::
#   The port of the Merb process to whom the the PID file belongs to.
#
# ==== Alternatives
# If Merb::Config[:pid_file] has been specified, that will be used
# instead of the port/socket based PID file.
#
# @api private
def remove_pid_file(port)
  pidfile = pid_file(port)
  if File.exist?(pidfile)
    Merb.logger.warn! "Removing pid file #{pidfile} (port/socket: #{port})..."
    FileUtils.rm(pidfile)
  end
end
</pre>